<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048</title>
    <style>
        /* --- General Styling --- */
        body {
            background-color: #0d1117; /* Deep biology dark blue */
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* Use min-height 100vh for full-screen on desktop, but be cautious on mobile */
            min-height: 100vh; 
            padding: 20px 0; /* Add padding for mobile content */
            margin: 0;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            color: #58a6ff;
            text-shadow: 0 0 10px rgba(88, 166, 255, 0.5);
            font-size: 2rem; /* Better size for mobile header */
        }

        .score-container {
            margin: 10px 0 20px 0;
            background: rgba(255,255,255,0.1);
            padding: 5px 20px;
            border-radius: 20px;
            font-size: 1rem;
            color: #8b949e;
        }

        #score { color: white; font-weight: bold; font-size: 1.2rem; }

        /* --- The Petri Dish (Grid) --- */
        .grid-container {
            position: relative;
            /* Use a max-width and percentage for mobile responsiveness */
            width: 90vw; 
            max-width: 360px; /* Slightly larger grid for easier tapping */
            height: 90vw;
            max-height: 360px;
            background-color: #161b22;
            border-radius: 10px;
            border: 2px solid #30363d;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }

        /* Empty slots in the background */
        .grid-cell {
            background-color: #21262d;
            border-radius: 6px;
        }

        /* The Moving Tiles (Dynamic sizing based on container) */
        .tile {
            position: absolute;
            /* Calculate tile size dynamically in JS to match grid */
            /* width and height will be set via JS in renderTile for precision */
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2rem; /* Adjusted for better look */
            font-weight: bold;
            transition: transform 0.15s ease-in-out; /* Smooth sliding */
            z-index: 10;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        /* Ensure the emoji/text is visible on all stages */
        .stage-2048, .stage-4096 {
            color: white !important; /* Override stage-256, stage-512 for high values */
            text-shadow: 0 0 5px black;
        }

        /* --- Evolution Stages (Colors - Extended) --- */
        .stage-2 { background: #238636; box-shadow: 0 0 10px #238636; } /* DNA - Green */
        .stage-4 { background: #1f6feb; box-shadow: 0 0 10px #1f6feb; } /* Microbe - Blue */
        .stage-8 { background: #a371f7; box-shadow: 0 0 10px #a371f7; } /* Shrimp - Purple */
        .stage-16 { background: #d29922; box-shadow: 0 0 10px #d29922; } /* Fish - Orange */
        .stage-32 { background: #db6d28; box-shadow: 0 0 10px #db6d28; } /* Lizard - Dark Orange */
        .stage-64 { background: #f85149; box-shadow: 0 0 10px #f85149; } /* Bird - Red */
        .stage-128 { background: #f0883e; } 
        .stage-256 { background: #f2cc60; color: black; } 
        .stage-512 { background: #3fb950; color: black; }
        .stage-1024 { background: #58a6ff; } /* Default blue */
        .stage-2048 { background: linear-gradient(45deg, #f0f, #0ff); animation: pulse 1s infinite; }
        .stage-4096 { background: #8e44ad; font-size: 2rem; animation: pulse 1s infinite alternate; } /* New stage */
        .stage-8192 { background: linear-gradient(45deg, #ff0, #00f); animation: pulse 0.8s infinite; } /* New stage */

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 15px currentColor; }
            50% { transform: scale(1.03); box-shadow: 0 0 25px currentColor; }
            100% { transform: scale(1); box-shadow: 0 0 15px currentColor; }
        }

        .pop-in {
            animation: pop 0.2s;
        }

        @keyframes pop {
            0% { transform: scale(0); }
            80% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* --- UI Buttons & Overlay --- */
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        .btn {
            background: #21262d;
            color: #c9d1d9;
            border: 1px solid #30363d;
            padding: 10px 20px; /* Larger padding for easier mobile tapping */
            border-radius: 6px;
            cursor: pointer;
            text-decoration: none;
            font-size: 1rem;
            transition: 0.2s;
        }

        .btn:hover { background: #30363d; color: white; }
        
        .game-over-overlay {
            position: absolute;
            /* Covers the grid container perfectly */
            top: 0; left: 0; 
            width: 100%; height: 100%;
            background: rgba(13, 17, 23, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
    </style>
</head>
<body>

    <h1>EVOLUTION LOOP</h1>
    <div class="score-container">Biomass: <span id="score">0</span></div>

    <div class="grid-container" id="grid-container">
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
        <div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div><div class="grid-cell"></div>
    </div>

    <div class="controls">
        <button class="btn" onclick="resetGame()">Reset Species</button>
        <a href="../index.html" class="btn">Exit Lab</a>
    </div>

    <div class="game-over-overlay" id="gameOver">
        <h2 style="color:#f85149">EXTINCTION EVENT</h2>
        <button class="btn" onclick="resetGame()">Re-Evolve</button>
    </div>

    <script>
        const gridContainer = document.getElementById('grid-container');
        const scoreEl = document.getElementById('score');
        const gameOverEl = document.getElementById('gameOver');
        
        let board = [];
        let score = 0;
        const size = 4;
        const TILE_TRANSITION_TIME = 150; // Milliseconds for visual slide
        let isMoving = false; // Guard to prevent multiple moves during animation

        // Extended Evolution Mapping for longer play
        const evolutionMap = {
            2: 'ðŸ§¬', // DNA
            4: 'ðŸ¦ ', // Microbe
            8: 'ðŸ¦', // Shrimp
            16: 'ðŸŸ', // Fish
            32: 'ðŸ¦Ž', // Lizard
            64: 'ðŸ¦…', // Bird
            128: 'ðŸº', // Wolf
            256: 'ðŸ¦', // Ape
            512: 'ðŸ§', // Human
            1024: 'ðŸ¦¾', // Cyborg
            2048: 'ðŸ¤–', // AI God
            4096: 'ðŸŒŒ',  // Universe
            8192: 'âš«' // Singularity
        };
        
        // --- Core Game Functions ---

        function resetGame() {
            board = Array(size * size).fill(0);
            score = 0;
            scoreEl.innerText = score;
            gameOverEl.style.display = 'none';
            isMoving = false;
            
            // Clear existing tiles from DOM
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(t => t.remove());
            
            addNewTile();
            addNewTile();
            renderBoard();
        }

        function addNewTile() {
            let available = [];
            for(let i=0; i<board.length; i++) {
                if(board[i] === 0) available.push(i);
            }

            if(available.length > 0) {
                let r = Math.floor(Math.random() * available.length);
                let idx = available[r];
                // 90% chance of a 2, 10% chance of a 4
                board[idx] = Math.random() < 0.9 ? 2 : 4; 
                
                // Animate entrance
                renderTile(idx, board[idx], true);
            }
        }

        // Logic: Slide & Merge (No change from original, it's perfect 2048 logic)
        function slide(row) {
            let arr = row.filter(val => val);
            let missing = size - arr.length;
            let zeros = Array(missing).fill(0);
            return arr.concat(zeros);
        }

        function combine(row) {
            let combined = false;
            for (let i = 0; i < size - 1; i++) {
                if (row[i] !== 0 && row[i] === row[i + 1]) {
                    row[i] *= 2;
                    row[i + 1] = 0;
                    score += row[i];
                    combined = true;
                }
            }
            return row;
        }

        function operate(row) {
            row = slide(row);
            row = combine(row);
            row = slide(row);
            return row;
        }

        // --- Move Functions (Simplified/Refactored for cleaner code) ---

        function move(direction) {
            if(isMoving) return false;
            let hasMoved = false;
            
            if (direction === 'left' || direction === 'right') {
                for (let i = 0; i < size; i++) {
                    let start = i * size;
                    let row = board.slice(start, start + size);
                    
                    if (direction === 'right') row.reverse();
                    let newRow = operate(row);
                    if (direction === 'right') newRow.reverse();
                    
                    if (row.toString() !== newRow.toString()) hasMoved = true;
                    for (let j = 0; j < size; j++) board[start + j] = newRow[j];
                }
            } else if (direction === 'up' || direction === 'down') {
                for (let i = 0; i < size; i++) {
                    let col = [];
                    for(let k = 0; k < size; k++) col.push(board[i + k * size]);

                    if (direction === 'down') col.reverse();
                    let newCol = operate(col);
                    if (direction === 'down') newCol.reverse();

                    if (col.toString() !== newCol.toString()) hasMoved = true;
                    for (let k = 0; k < size; k++) board[i + k * size] = newCol[k];
                }
            }
            return hasMoved;
        }


        // --- Input Handling & Game Loop ---

        function handleInput(e) {
            let moved = false;
            const key = e.key;

            if (key === 'ArrowLeft') moved = move('left');
            else if (key === 'ArrowRight') moved = move('right');
            else if (key === 'ArrowUp') moved = move('up');
            else if (key === 'ArrowDown') moved = move('down');

            if (moved) endTurn();
        }

        function endTurn() {
            isMoving = true; // Lock input
            scoreEl.innerText = score;
            renderBoard(); // Update Visuals (The transition happens here)
            
            setTimeout(() => {
                addNewTile();
                isMoving = false; // Unlock input after animation

                if (checkGameOver()) {
                    gameOverEl.style.display = 'flex';
                }
            }, TILE_TRANSITION_TIME + 50); // Wait for tile animation + a little buffer
        }

        // --- Game Over Check Improvement ---

        function checkGameOver() {
            // If there's an empty spot, the game is NOT over
            for(let i=0; i<board.length; i++) if(board[i] === 0) return false;
            
            // Check for possible horizontal merges
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size - 1; j++) {
                    let idx1 = i * size + j;
                    let idx2 = i * size + j + 1;
                    if (board[idx1] === board[idx2]) return false;
                }
            }

            // Check for possible vertical merges
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size - 1; j++) {
                    let idx1 = i + j * size;
                    let idx2 = i + (j + 1) * size;
                    if (board[idx1] === board[idx2]) return false;
                }
            }

            return true; // No empty spots and no possible moves
        }


        // --- Visual Rendering System ---

        let TILE_SIZE = 0;
        let TILE_GAP = 0;
        let GRID_PADDING = 0;

        function calculateGridMetrics() {
            const gridStyle = window.getComputedStyle(gridContainer);
            // Get actual dimensions from CSS
            const containerWidth = gridContainer.clientWidth;
            GRID_PADDING = parseFloat(gridStyle.paddingLeft);
            TILE_GAP = parseFloat(gridStyle.gap);

            // Calculate one tile's size based on the grid structure
            // Width = (4 * Tile + 3 * Gap + 2 * Padding)
            // (ContainerWidth - 2 * Padding - 3 * Gap) / 4
            TILE_SIZE = (containerWidth - (2 * GRID_PADDING) - (3 * TILE_GAP)) / size;
        }

        function renderBoard() {
            calculateGridMetrics(); // Recalculate size on render for responsiveness

            // Remove old tiles
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(t => t.remove());

            // Add new tiles based on board array
            for(let i=0; i<board.length; i++) {
                if(board[i] !== 0) {
                    renderTile(i, board[i], false);
                }
            }
        }

        function renderTile(index, value, isNew) {
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.classList.add(`stage-${value}`);
            // Cap CSS classes for stages beyond the defined ones
            if (value > 4096) tile.classList.add('stage-8192'); 
            else if (value > 2048) tile.classList.add('stage-4096');
            else if (value > 1024) tile.classList.add('stage-2048');
            
            if (isNew) tile.classList.add('pop-in');

            tile.innerText = evolutionMap[value] || value;

            // Calculate Position
            const x = (index % size);
            const y = Math.floor(index / size);
            
            // Set dynamic size
            tile.style.width = TILE_SIZE + 'px';
            tile.style.height = TILE_SIZE + 'px';
            
            // Position: Padding + (TileSize + Gap) * PosIndex
            tile.style.left = (GRID_PADDING + x * (TILE_SIZE + TILE_GAP)) + 'px';
            tile.style.top = (GRID_PADDING + y * (TILE_SIZE + TILE_GAP)) + 'px';

            gridContainer.appendChild(tile);
        }

        // --- Mobile Swipe Logic ---

        let touchstartX = 0;
        let touchstartY = 0;
        const SWIPE_THRESHOLD = 50; // Minimum pixel distance for a swipe

        gridContainer.addEventListener('touchstart', e => {
            touchstartX = e.changedTouches[0].screenX;
            touchstartY = e.changedTouches[0].screenY;
        }, false);

        gridContainer.addEventListener('touchend', e => {
            let touchendX = e.changedTouches[0].screenX;
            let touchendY = e.changedTouches[0].screenY;

            let deltaX = touchendX - touchstartX;
            let deltaY = touchendY - touchstartY;

            let moved = false;
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
                    moved = deltaX > 0 ? move('right') : move('left');
                }
            } else {
                // Vertical swipe
                if (Math.abs(deltaY) > SWIPE_THRESHOLD) {
                    moved = deltaY > 0 ? move('down') : move('up');
                }
            }

            if(moved) endTurn();

        }, false);

        // --- Initialization ---

        window.addEventListener('keydown', handleInput);
        window.addEventListener('resize', renderBoard); // Handle rotation/resize
        resetGame();

    </script>
</body>
</html>