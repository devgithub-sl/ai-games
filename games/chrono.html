<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chrono Stack</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; touch-action: none; }
        
        /* Standard UI */
        #ui {
            position: absolute;
            top: 10px; left: 10px;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            pointer-events: none;
            z-index: 10;
        }

        h1 { margin: 0; text-transform: uppercase; font-size: 1.5rem; }
        p { margin: 5px 0; font-size: 1rem; color: #aaa; }
        
        .key { display: none; } /* Hide desktop keys */

        #message {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 20;
        }

        #message h2 { font-size: 3rem; color: #0f0; text-shadow: 0 0 20px #0f0; margin: 0; }
        
        button {
            margin-top: 20px;
            padding: 10px 30px;
            background: transparent; border: 2px solid #0ff; color: #0ff;
            font-size: 1.2rem; cursor: pointer; pointer-events: auto;
            text-transform: uppercase;
        }
        button:hover { background: #0ff; color: #000; }

        .btn-back {
            position: absolute; bottom: 10px; left: 10px;
            text-decoration: none; color: #555; border: 1px solid #555; padding: 5px 10px;
            font-size: 0.8rem;
            pointer-events: auto; transition: 0.2s;
            z-index: 10;
        }
        .btn-back:hover { color: white; border-color: white; }

        #target-indicator {
            position: absolute; top: 10px; right: 10px;
            font-size: 1.2rem; color: #ffd700;
            z-index: 10;
        }

        /* --- MOBILE CONTROLS --- */
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 10px;
            z-index: 10;
        }
        
        .action-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.4);
            border: 2px solid #0ff;
            color: white;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 0 5px black;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Joystick Area (Simplified for 3D) */
        #joystick-area {
            position: relative;
            width: 150px;
            height: 150px;
        }
        
        #joystick-base {
            position: absolute;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #joystick-handle {
            position: absolute;
            width: 40px;
            height: 40px;
            background: #0ff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
        
    </style>
</head>
<body>

    <div id="ui">
        <h1>CHRONO STACK</h1>
        <p>Iteration: <span id="level-display" style="color:white">1</span></p>
        <p>Ghosts Used: <span id="ghost-count" style="color: white">0</span></p>
        <p class="key">Controls: <span class="key">WASD</span> Move | <span class="key">SPACE</span> Jump | <span class="key">F</span> Lock</p>
    </div>

    <div id="target-indicator">HEIGHT LEFT: <span id="height-dist">0.0</span>m</div>

    <div id="message">
        <h2 id="msg-title">SEQUENCE COMPLETE</h2>
        <button onclick="nextLevel()">NEXT ITERATION</button>
    </div>

    <a href="../index.html" class="btn-back">EXIT SIMULATION</a>
    
    <div class="mobile-controls">
        <div id="joystick-area">
            <div id="joystick-base"></div>
            <div id="joystick-handle"></div>
        </div>
        <div>
            <div class="action-button" id="lock-btn">LOCK</div>
            <div style="height: 10px;"></div>
            <div class="action-button" id="jump-btn">JUMP</div>
        </div>
    </div>

    <script>
        // --- SETUP (THREE.js unchanged) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lights... (unchanged)
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- GAME OBJECTS (unchanged) ---
        
        // Floor (unchanged)
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.8, metalness: 0.2 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Grid Helper (unchanged)
        const gridHelper = new THREE.GridHelper(100, 50, 0x00ffff, 0x222222);
        scene.add(gridHelper);

        // The Player (unchanged)
        const playerGeo = new THREE.BoxGeometry(1, 1, 1);
        const playerMat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x004444 });
        const player = new THREE.Mesh(playerGeo, playerMat);
        player.castShadow = true;
        scene.add(player);

        // The Goal (unchanged)
        const goalGeo = new THREE.OctahedronGeometry(0.8);
        const goalMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffaa00, wireframe: true });
        const goal = new THREE.Mesh(goalGeo, goalMat);
        const goalLight = new THREE.PointLight(0xffd700, 1, 10);
        goal.add(goalLight);
        scene.add(goal);

        // Ghosts Array (unchanged)
        let ghosts = [];
        let ghostMeshes = [];

        // Game State
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let onGround = true;
        let level = 1;
        
        // Physics Consts
        const SPEED = 0.15;
        const GRAVITY = 0.02;
        const JUMP_FORCE = 0.4;

        // Inputs
        const keys = { w: false, a: false, s: false, d: false, space: false }; // Keep for desktop input

        // --- Mobile Joystick State ---
        let joystickActive = false;
        let joystickX = 0;
        let joystickY = 0;
        const JOYSTICK_MAX_DISTANCE = 50;

        // --- Core Game Functions (mostly unchanged) ---
        
        // ** LOCK LOGIC (Modified to be called by 'F' or mobile button) **
        function handleLock() {
            if (ghosts.length >= getMaxGhosts()) {
                // Optional: Feedback for resource limit
                player.material.color.setHex(0xff0000);
                setTimeout(() => player.material.color.setHex(0x00ffff), 100);
                return; 
            }
            createGhost(player.position.clone());
            respawn();
        }

        function createGhost(pos) {
            // ... (unchanged)
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x444444, 
                transparent: true, 
                opacity: 0.8,
                roughness: 0.1
            });
            const ghost = new THREE.Mesh(geo, mat);
            ghost.position.copy(pos);
            ghost.castShadow = true;
            ghost.receiveShadow = true;
            
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ffff }));
            ghost.add(line);

            scene.add(ghost);
            ghostMeshes.push(ghost);
            ghosts.push(new THREE.Box3().setFromObject(ghost));

            document.getElementById('ghost-count').innerText = ghosts.length;
        }

        function respawn() {
            player.position.set(0, 0.5, 5); // Start position
            velocity.set(0, 0, 0);
            
            player.material.color.setHex(0xffffff);
            setTimeout(() => player.material.color.setHex(0x00ffff), 200);
        }

        // Collision, Ground, Win Checks (unchanged)
        function checkCollision(newPos) {
            const playerBox = new THREE.Box3().setFromCenterAndSize(newPos, new THREE.Vector3(0.9, 0.9, 0.9));
            for (let box of ghosts) {
                if (playerBox.intersectsBox(box)) return true;
            }
            return false;
        }

        function checkGround(newPos) {
            const feetPos = newPos.clone();
            feetPos.y -= 0.1;
            const playerBox = new THREE.Box3().setFromCenterAndSize(feetPos, new THREE.Vector3(0.8, 0.9, 0.8));

            for (let box of ghosts) {
                if (playerBox.intersectsBox(box)) {
                    if (newPos.y > box.max.y) {
                        return { isGrounded: true, y: box.max.y + 0.5 };
                    }
                }
            }
            
            if (newPos.y <= 0.5) return { isGrounded: true, y: 0.5 };
            return { isGrounded: false, y: 0 };
        }

        function checkWin() {
            const dist = player.position.distanceTo(goal.position);
            if (dist < 1.5) {
                document.getElementById('message').style.display = 'block';
                // Rotate goal wildly
                goal.rotation.x += 0.5;
            }
        }
        
        // --- DIFFICULTY CURVE & LEVELING ---
        
        // Exponentially increase height
        function getGoalHeight(level) {
            return 5 + (level - 1) * 3 + Math.pow(level, 1.5); // 5, 9, 15.6, 25.5, 39.1...
        }
        
        // Limited resource constraint to increase difficulty
        function getMaxGhosts() {
            return level * 5 + 10; // 15, 20, 25...
        }

        function nextLevel() {
            level++;
            
            // Clear scene
            ghostMeshes.forEach(g => scene.remove(g));
            ghostMeshes = [];
            ghosts = [];

            document.getElementById('level-display').innerText = level;
            document.getElementById('ghost-count').innerText = '0';
            document.getElementById('message').style.display = 'none';

            // Increase Difficulty (Higher Goal)
            goal.position.set(0, getGoalHeight(level), -5);
            
            respawn();
        }

        // --- UPDATE LOOP ---
        function update() {
            // 1. Movement Input (Prioritize Mobile > Desktop)
            
            let dx = 0;
            let dz = 0;
            
            if (joystickActive) {
                dx = joystickX / JOYSTICK_MAX_DISTANCE; // -1 to 1
                dz = joystickY / JOYSTICK_MAX_DISTANCE; // -1 to 1 (Y is Z in 3D)
                
                // Since our camera is fixed, a simple 2D direction map works
                direction.set(dx, 0, dz); 
                direction.normalize();
                
            } else {
                // Desktop Input
                direction.set(0, 0, 0);
                if (keys.w) direction.z = -1;
                if (keys.s) direction.z = 1;
                if (keys.a) direction.x = -1;
                if (keys.d) direction.x = 1;
                direction.normalize();
            }


            // 2. Apply Velocity (Horizontal)
            if (direction.length() > 0) {
                velocity.x = direction.x * SPEED;
                velocity.z = direction.z * SPEED;
            } else {
                velocity.x = 0;
                velocity.z = 0;
            }

            // 3. Apply Gravity
            velocity.y -= GRAVITY;

            // 4. Position Update and Collisions (X/Z)
            let proposedPos = player.position.clone();
            proposedPos.x += velocity.x;
            proposedPos.z += velocity.z;
            if (!checkCollision(proposedPos)) {
                player.position.x = proposedPos.x;
                player.position.z = proposedPos.z;
            }

            // 5. Position Update and Collisions (Y)
            proposedPos = player.position.clone();
            proposedPos.y += velocity.y;
            
            if (velocity.y > 0 && checkCollision(proposedPos)) {
                velocity.y = 0; // Bonk head
            } else {
                const groundInfo = checkGround(proposedPos);
                if (velocity.y < 0 && groundInfo.isGrounded) {
                    player.position.y = groundInfo.y;
                    velocity.y = 0;
                    onGround = true;
                } else {
                    player.position.y = proposedPos.y;
                    onGround = false;
                }
            }
            
            if (player.position.y < 0.5) {
                player.position.y = 0.5;
                velocity.y = 0;
                onGround = true;
            }

            // 6. Jump Execution
            if (keys.space && onGround) { // Space key for desktop jump
                velocity.y = JUMP_FORCE;
                onGround = false;
            }

            // 7. Camera Follow (Fixed Isometric)
            camera.position.x = player.position.x + 10;
            camera.position.y = player.position.y + 10;
            camera.position.z = player.position.z + 10;
            camera.lookAt(player.position);

            // 8. Goal Animation
            goal.rotation.y += 0.02;
            goal.rotation.z += 0.01;
            
            // 9. Distance UI
            const distY = Math.max(0, goal.position.y - player.position.y).toFixed(1);
            document.getElementById('height-dist').innerText = distY;

            checkWin();
        }

        // --- INPUT BINDINGS (Mobile & Desktop) ---

        // Desktop Key Bindings (Updated to include Jump and Lock)
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
            if (e.code === 'KeyF') handleLock();
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
        });

        // Mobile Button Bindings
        document.getElementById('jump-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (onGround) {
                velocity.y = JUMP_FORCE;
                onGround = false;
            }
        });

        document.getElementById('lock-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleLock();
        });
        
        // --- MOBILE JOYSTICK LOGIC ---
        const joystickArea = document.getElementById('joystick-area');
        const joystickHandle = document.getElementById('joystick-handle');
        const joystickCenter = { x: 75, y: 75 };

        function getJoystickPos(e) {
            let touch = e.touches[0] || e.changedTouches[0];
            let rect = joystickArea.getBoundingClientRect();
            
            let localX = touch.clientX - rect.left - joystickCenter.x;
            let localY = touch.clientY - rect.top - joystickCenter.y;

            let distance = Math.sqrt(localX * localX + localY * localY);
            let angle = Math.atan2(localY, localX);

            // Clamp position to JOYSTICK_MAX_DISTANCE
            if (distance > JOYSTICK_MAX_DISTANCE) {
                localX = Math.cos(angle) * JOYSTICK_MAX_DISTANCE;
                localY = Math.sin(angle) * JOYSTICK_MAX_DISTANCE;
            }
            
            joystickHandle.style.left = (localX + joystickCenter.x) + 'px';
            joystickHandle.style.top = (localY + joystickCenter.y) + 'px';

            joystickX = localX;
            joystickY = localY;
            joystickActive = true;
        }

        function resetJoystick() {
            joystickHandle.style.left = '50%';
            joystickHandle.style.top = '50%';
            joystickX = 0;
            joystickY = 0;
            joystickActive = false;
        }

        joystickArea.addEventListener('touchstart', getJoystickPos, false);
        joystickArea.addEventListener('touchmove', getJoystickPos, false);
        joystickArea.addEventListener('touchend', resetJoystick, false);
        joystickArea.addEventListener('touchcancel', resetJoystick, false);


        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        
        // Initial setup
        respawn();
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>