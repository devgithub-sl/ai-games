<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Laser Logic (Optimized)</title>
    <style>
        body {
            background-color: #222;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            user-select: none; 
            touch-action: none; /* Crucial for mobile performance */
        }

        h1 { margin-bottom: 10px; color: #f44336; text-shadow: 0 0 10px #f44336; font-size: 1.5rem; }

        /* Game Container - RESPONSIVE SCALING */
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 3px solid #444;
            background: #111;
            
            /* Use viewport units for scaling */
            width: 90vw;
            max-width: 600px;
            /* Calculate height based on 600/400 ratio */
            height: calc(90vw * 400 / 600);
            max-height: 400px;
        }

        canvas { 
            display: block; 
            cursor: pointer; 
            width: 100%; /* Fill container */
            height: 100%;
        }

        #level-info {
            position: absolute;
            top: 5px; left: 5px;
            font-size: 1rem;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 10;
        }

        #win-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .win-text {
            font-size: 2rem;
            color: #4CAF50;
            text-shadow: 0 0 20px #4CAF50;
            margin-bottom: 20px;
        }

        button {
            background: #333;
            color: white;
            border: 2px solid #555;
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            margin: 5px;
            border-radius: 4px;
            /* Ensure buttons are easy to tap */
            -webkit-tap-highlight-color: transparent; 
        }
        button:hover { background: #444; border-color: #aaa; }
        .btn-next { background: #4CAF50; border-color: #4CAF50; color: black; font-weight: bold; }

        .controls-row { margin-top: 15px; }
        .btn-back { text-decoration: none; display: inline-block; }
    </style>
</head>
<body>

    <h1>LASER LOGIC</h1>

    <div id="game-container">
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div id="level-info">Level: <span id="level-num">1</span></div>
        
        <div id="win-overlay">
            <div class="win-text">TARGET ACQUIRED</div>
            <button class="btn-next" onclick="nextLevel()">Next Level</button>
        </div>
    </div>

    <div class="controls-row">
        <button onclick="resetLevel()">Reset Level</button>
        <a href="../index.html" class="btn-back"><button>Back to Arcade</button></a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelNumEl = document.getElementById('level-num');
        const winOverlay = document.getElementById('win-overlay');

        const gridSize = 60; 
        const cols = canvas.width / gridSize;
        const rows = canvas.height / gridSize;

        // --- Game Assets/Types ---
        // 0=Empty, 1=Emitter(Right), 2=Target, 3=Wall, 
        // 4=Mirror(/), 5=Mirror(\), 6=Prism(Splitter)
        
        const levels = [
            // Level 1: Simple reflection
            [
                [3,3,3,3,3,3,3,3,3,3],
                [3,0,0,0,0,0,0,0,0,3],
                [1,0,0,4,0,0,0,0,0,3],
                [3,0,0,0,0,0,0,0,0,3],
                [3,0,0,0,0,0,5,0,0,3],
                [3,0,0,0,0,0,0,0,0,3],
                [3,0,0,2,0,0,0,0,0,3],
                [3,0,0,0,0,0,0,0,0,3],
                [3,3,3,3,3,3,3,3,3,3]
            ],
             // Level 2: Double reflection
            [
                [3,3,3,3,3,3,3,3,3,3],
                [1,0,0,0,0,5,0,0,0,3],
                [3,0,3,3,3,0,3,3,0,3],
                [3,0,0,0,0,0,0,0,0,3],
                [3,0,3,3,3,0,3,3,0,3],
                [3,0,0,4,0,0,0,0,0,3],
                [3,3,3,0,3,3,3,0,3,3],
                [3,0,0,0,0,0,0,0,2,3],
                [3,3,3,3,3,3,3,3,3,3]
            ],
            // Level 3: Zig Zag
            [
                [3,3,3,3,3,3,3,3,3,3],
                [3,0,0,0,0,0,0,0,2,3],
                [3,0,4,0,5,0,4,0,0,3],
                [3,0,0,0,0,0,0,0,0,3],
                [3,0,0,0,0,0,0,0,0,3],
                [3,0,0,0,0,0,0,0,0,3],
                [3,0,5,0,4,0,5,0,0,3],
                [1,0,0,0,0,0,0,0,0,3],
                [3,3,3,3,3,3,3,3,3,3]
            ],
            // Level 4: Introduction to Prism (Type 6)
            [
                [3,3,3,3,3,3,3,3,3,3],
                [1,0,0,0,0,0,0,0,0,3],
                [3,0,0,6,0,0,0,0,0,3], 
                [3,0,0,0,0,0,0,0,0,3],
                [3,0,0,4,0,0,0,0,0,3],
                [3,0,0,0,0,0,0,0,0,3],
                [3,2,0,0,0,0,0,0,2,3], /* Two targets */
                [3,0,0,0,0,0,0,0,0,3],
                [3,3,3,3,3,3,3,3,3,3]
            ],
            // Level 5: Complex Prism
            [
                [3,3,3,3,3,3,3,3,3,3],
                [3,0,0,0,0,0,0,0,2,3], 
                [1,0,0,5,0,0,6,0,0,3], 
                [3,0,3,3,3,3,0,3,3,3], 
                [3,0,0,4,0,0,4,0,0,3],
                [3,0,3,3,3,3,0,3,3,3],
                [3,2,0,0,0,0,0,0,0,3], 
                [3,0,0,0,0,0,0,0,0,3],
                [3,3,3,3,3,3,3,3,3,3]
            ]
        ];

        let currentLevel = 0;
        let grid = [];
        let emitter = {c:0, r:0, dir:{x:1, y:0}}; 
        let targetsHit = 0;
        let requiredTargets = 0;
        let laserPaths = []; 
        let levelWon = false;
        
        // --- NEW TRACKERS ---
        let targetPositions = []; // Store {c, r} of all targets
        let targetStates = []; // Store hit state (true/false) for each target
        
        let initialGrid = [];

        function loadLevel(lvlIdx) {
            if(lvlIdx >= levels.length) {
                alert("All Systems Operational! Game Completed. Restarting.");
                currentLevel = 0;
            }
            
            initialGrid = JSON.parse(JSON.stringify(levels[currentLevel]));
            grid = JSON.parse(JSON.stringify(initialGrid));

            levelNumEl.innerText = currentLevel + 1;
            winOverlay.style.display = 'none';
            levelWon = false;
            targetsHit = 0;
            requiredTargets = 0;
            targetPositions = [];
            targetStates = [];
            
            // Find Emitter and count Targets
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(grid[r][c] === 1) emitter = {c:c, r:r, dir:{x:1, y:0}};
                    if(grid[r][c] === 2) {
                        requiredTargets++;
                        targetPositions.push({c: c, r: r}); // Store position
                        targetStates.push(false); // Initialize state to false
                    }
                }
            }
            
            calculateLaser();
            draw();
        }
        
        // --- Core Laser Calculation Logic ---
        function calculateLaser() {
            laserPaths = [];
            targetsHit = 0;
            // Reset ALL target hit states before tracing
            targetStates = targetStates.map(() => false);
            
            // The laser starts as a single beam
            traceBeam({c: emitter.c, r: emitter.r, dx: emitter.dir.x, dy: emitter.dir.y});
            
            // Count actual hits
            targetsHit = targetStates.filter(state => state).length;
            
            // Check win condition
            if (targetsHit === requiredTargets && requiredTargets > 0) {
                levelWon = true;
                winOverlay.style.display = 'flex';
            } else {
                levelWon = false;
                winOverlay.style.display = 'none';
            }
        }

        // Recursive function to trace a single laser beam
        function traceBeam(start) {
            let c = start.c;
            let r = start.r;
            let dx = start.dx;
            let dy = start.dy;
            
            let path = [];
            
            path.push({ x: c * gridSize + gridSize/2, y: r * gridSize + gridSize/2 });

            for(let i=0; i<50; i++) {
                c += dx;
                r += dy;
                
                if(c < 0 || c >= cols || r < 0 || r >= rows) break;
                
                path.push({ x: c * gridSize + gridSize/2, y: r * gridSize + gridSize/2 });

                const tile = grid[r][c];

                if (tile === 2) { // Target
                    // Find which target was hit and mark its state
                    const targetIndex = targetPositions.findIndex(pos => pos.c === c && pos.r === r);
                    if (targetIndex !== -1) {
                        targetStates[targetIndex] = true;
                    }
                    break; 
                }
                else if (tile === 3 || tile === 1) { // Wall or Emitter
                    break;
                }
                else if (tile === 4) { // Mirror / (dx_new = -dy, dy_new = -dx)
                    let temp = dx;
                    dx = -dy;
                    dy = -temp;
                }
                else if (tile === 5) { // Mirror \ (dx_new = dy, dy_new = dx)
                    let temp = dx;
                    dx = dy;
                    dy = temp;
                }
                else if (tile === 6) { // PRISM (SPLITTER)
                    if (dx !== 0) {
                        traceBeam({c: c, r: r, dx: 0, dy: 1});
                        traceBeam({c: c, r: r, dx: 0, dy: -1});
                    } 
                    else if (dy !== 0) {
                        traceBeam({c: c, r: r, dx: 1, dy: 0});
                        traceBeam({c: c, r: r, dx: -1, dy: 0});
                    }
                    break;
                }
            }
            
            if(path.length > 1) {
                laserPaths.push(path);
            }
        }
        
        // --- Drawing Functions ---
        function draw() {
            // 1. Clear Screen
            ctx.fillStyle = '#111';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            
            // 2. Draw Grid Lines (Subtle)
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=0; i<=cols; i++) { ctx.moveTo(i*gridSize,0); ctx.lineTo(i*gridSize, canvas.height); }
            for(let i=0; i<=rows; i++) { ctx.moveTo(0,i*gridSize); ctx.lineTo(canvas.width, i*gridSize); }
            ctx.stroke();

            // 3. Draw Tiles
            let targetIndexCounter = 0;
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    const type = grid[r][c];
                    const x = c * gridSize;
                    const y = r * gridSize;
                    
                    if(type === 3) { // Wall
                        ctx.fillStyle = '#444'; ctx.fillRect(x+1, y+1, gridSize-2, gridSize-2);
                    } else if (type === 1) { // Emitter
                        ctx.fillStyle = '#555'; ctx.fillRect(x+1, y+1, gridSize-2, gridSize-2);
                        // Nub pointing right
                        ctx.fillStyle = '#f44336'; 
                        ctx.beginPath(); ctx.arc(x+gridSize-10, y+gridSize/2, 8, 0, Math.PI*2); ctx.fill();
                    } else if (type === 2) { // Target
                        // *** FIX HERE: Pass the specific hit state ***
                        drawTarget(x, y, targetStates[targetIndexCounter]);
                        targetIndexCounter++; // Move to next target state
                    } else if (type === 4 || type === 5) { // Mirrors
                        drawMirror(x, y, type === 4 ? '/' : '\\');
                    } else if (type === 6) { // Prism (Splitter)
                        drawPrism(x, y);
                    }
                }
            }

            // 4. Draw Lasers (unchanged)
            laserPaths.forEach(path => {
                if(path.length > 1) {
                    // Outer Glow
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#f00';
                    ctx.strokeStyle = '#f44336';
                    ctx.lineWidth = 5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(path[0].x, path[0].y);
                    for(let i=1; i<path.length; i++) {
                        ctx.lineTo(path[i].x, path[i].y);
                    }
                    ctx.stroke();
                    
                    // Inner White Core (for "hot" look)
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(path[0].x, path[0].y);
                    for(let i=1; i<path.length; i++) {
                        ctx.lineTo(path[i].x, path[i].y);
                    }
                    ctx.stroke();
                }
            });
        }

        function drawMirror(x, y, type) {
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(x+2, y+2, gridSize-4, gridSize-4);
            
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 4;
            ctx.beginPath();
            
            const surfaceColor = '#00bcd4'; 
            
            if(type === '/') {
                ctx.moveTo(x+10, y+gridSize-10); ctx.lineTo(x+gridSize-10, y+10);
                ctx.stroke();
                
                ctx.strokeStyle = surfaceColor;
                ctx.beginPath();
                ctx.moveTo(x+8, y+gridSize-12); ctx.lineTo(x+gridSize-12, y+8);
                ctx.stroke();
            } else {
                ctx.moveTo(x+10, y+10); ctx.lineTo(x+gridSize-10, y+gridSize-10);
                ctx.stroke();
                
                ctx.strokeStyle = surfaceColor;
                ctx.beginPath();
                ctx.moveTo(x+12, y+8); ctx.lineTo(x+gridSize-8, y+gridSize-12);
                ctx.stroke();
            }
        }
        
        function drawPrism(x, y) {
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(x+2, y+2, gridSize-4, gridSize-4);
            
            ctx.fillStyle = '#8bc34a'; // Green/Glass color
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            
            // Draw a triangle for the prism look
            ctx.beginPath();
            ctx.moveTo(x + 10, y + gridSize - 10);
            ctx.lineTo(x + gridSize - 10, y + gridSize - 10);
            ctx.lineTo(x + gridSize / 2, y + 10);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        
        function drawTarget(x, y, hit) {
            ctx.fillStyle = '#333'; ctx.fillRect(x+1, y+1, gridSize-2, gridSize-2);
            
            const color = hit ? '#4CAF50' : '#888';
            
            ctx.fillStyle = color; 
            ctx.beginPath(); ctx.arc(x+gridSize/2, y+gridSize/2, 12, 0, Math.PI*2); ctx.fill();
            
            ctx.strokeStyle = hit ? '#fff' : '#888'; ctx.lineWidth=2; 
            ctx.beginPath(); ctx.arc(x+gridSize/2, y+gridSize/2, 16, 0, Math.PI*2); ctx.stroke();
        }

        // --- Input Handling (Mobile Optimized) ---
        
        function rotateTile(clientX, clientY) {
            if(levelWon) return;

            const rect = canvas.getBoundingClientRect();
            
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;

            const c = Math.floor(canvasX / gridSize);
            const r = Math.floor(canvasY / gridSize);

            if(c < 0 || c >= cols || r < 0 || r >= rows) return;

            const tile = grid[r][c];
            let changed = false;

            if(tile === 4) {
                grid[r][c] = 5;
                changed = true;
            } else if (tile === 5) {
                grid[r][c] = 4;
                changed = true;
            }

            if(changed) {
                calculateLaser();
                draw(); 
            }
        }

        // 1. Desktop Click
        canvas.addEventListener('mousedown', (e) => {
            if (e.target.tagName !== 'CANVAS') return;
            rotateTile(e.clientX, e.clientY);
        });

        // 2. Mobile Tap/Touch
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            
            if (e.touches.length > 0) {
                rotateTile(e.touches[0].clientX, e.touches[0].clientY);
            }
        });


        // --- Control Functions ---
        function nextLevel() {
            currentLevel++;
            loadLevel(currentLevel);
        }

        function resetLevel() {
            grid = JSON.parse(JSON.stringify(initialGrid));
            calculateLaser();
            draw();
        }

        // Init
        loadLevel(currentLevel);

    </script>
</body>
</html>